#ProgrammingExercises

*This project is consist of my programming exercises, including Data Structure, Operator, Sorting, Exercises from "Cracking Coding Interview" and other General Issues*

======
###CONTENT
1. [Data Structure](#1)
2. [Operator] (#2)
3. [Sorting] (#3)
4. [Exercises from "Cracking Coding Interview"] (#4)
5. [Exercises from LeetCode] (#5)
6. [General Issue] (#6)
 
======
###<a name="1"></a>DATA STRUCTURE
1. TRIE
2. LINKED LIST

###<a name="2"></a>OPERATOR
1. EXCLUSIVE OR
2. BITWISE OPERATIONS
3. TERNARY OPERATORS

###<a name="3"></a>SORTING
1. INSERTION SORT
2. MERGE SORT
3. HEAP SORT
4. QUICK SORT
5. COUNTING SORT

###<a name="4"></a>EXERCISE FROM CRACKING THE CODING INTERVIEW
1. EXERCISE 19-10
    - Use a function that generate Integer in range (1, 5) to generate Interger in range (1, 7) randomly
    - There are various implementations for this exercise. **An interesting question is how to control the distribution if needed.** If there is any restriction on the output, can the new integer generator remain the same distribution? For uniform distribution, it is possible. However, if the origin generator outputs in normal distribution, some integral transform is required
2. EXERCISE 19-08
    - Need more clarification: how many searches will I need to perform? If more than once, I need to build a table for the frequency of each word. Besides, is the search case-sensitive? Should singular/plural, possessive forms of nouns to be considered?
3. EXERCISE 19-05
4. EXERCISE 19-03
5. EXERCISE 19-01
6. EXERCISE 19-05
    - Reflection and Annotation in Java
7. EXERCISE 14-04
8. EXERCISE 14-03
9. EXERCISE 14-02
10. EXERCISE 14-01
11. EXERCISE 11-01
12. EXERCISE 10-07
    - Solved with brute force ):
13. EXERCISE 10-03
14. EXERCISE 9-06
15. EXERCISE 9-05
16. EXERCISE 9-02
17. EXERCISE 9-01
18. EXERCISE 8-08
19. EXERCISE 8-07
20. EXERCISE 8-06
21. EXERCISE 8-05
22. EXERCISE 8-04
23. EXERCISE 8-03
24. EXERCISE 8-02
25. EXERCISE 8-01
26. EXERCISE 7-05
27. EXERCISE 7-02
28. EXERCISE 6-06
29. EXERCISE 6-03
    - A.K.A. [Water Pouring Problem] (http://demonstrations.wolfram.com/WaterPouringProblem/)
30. EXERCISE 5-06
31. EXERCISE 5-05
32. EXERCISE 5-01
33. EXERCISE 4-08
34. EXERCISE 4-07
35. EXERCISE 4-06
36. EXERCISE 4-05
37. EXERCISE 4-03
38. EXERCISE 3-06
39. EXERCISE 3-05
40. EXERCISE 3-04
41. EXERCISE 3-03
42. EXERCISE 3-02
43. EXERCISE 3-01
44. EXERCISE 2-05
45. EXERCISE 2-04
46. EXERCISE 2-03
47. EXERCISE 2-02
48. EXERCISE 2-01
49. EXERCISE 1-08
50. EXERCISE 1-07
51. EXERCISE 1-06
52. EXERCISE 1-05
53. EXERCISE 1-04
54. EXERCISE 1-03
55. EXERCISE 1-02
56. EXERCISE 1-01

###<a name="5"></a>EXERCISES FROM LEETCODE
1. Same Tree
2. Reverse Integer
3. Best Time to Buy Stock
4. Linked List Cycle
5. Unique Binary Search Trees
6. Populating Next Right Pointers
7. Remove Duplicates from Sorted List
8. Search Insert Position
9. Maximum Depth of Tree
10. Single Number Problem
11. Binary Tree Inorder Traversal
12. Binary Tree Preorder Traversal
    - It is within BinaryTreeInorderTraversal.java
13. Remove Element
14. Remove Duplicates From Sorted Array
15. Maximum Subarray
16. Climbing Stairs
17. Roman to Integer
18. Merge Two Sorted Lists
19. Merge Sorted Array
20. Symmetric Tree
21. Balanced Binary Tree
22. Best Time to Buy and Sell Stock IIi
    - Refer with "Best Time to Buy and Sell Stock"
    - When only one sell is allowed, it is in fact a Maximum Subarray Problem of the array contains profit of each day
23. Convert Sorted Array to Binary Search Tree
24. Integer to Roman
25. Pascal's Triangle
26. Single Number II
    - Refer with "Single Number Problem". Instead of twice, the noises are repeated three times this time
27. Swap Nodes in Pairs
28. Gray Code
29. Permutations
    - Recursion
30. Binary Tree Level Order Traversal II
    - Breadth first traversal
31. Generate Parentheses
32. Minimum Path Sum
    - Recursion works just fine, but solving with for-loop and some extra memory will improve the speed
33. Sort Colors
34. Linked List Cycle II
35. Rotate Image
36. Unique Paths
37. Binary Tree Level Order Traversal
38. Binary Tree Postorder Traversal
39. Set Matrix Zeroes
40. Container With Most Water
41. Plus One
42. Remove Nth Node from End of List
43. Search A 2D Matrix
44. Spiral Matrix II
45. Combinations
46. Pascals Triangle II
47. Path Sum
48. Remove Duplicates From Sorted Array II
49. Search in Rotated Sorted Array
50. Search in Rotated Sorted Array II
    - Note that "Search in Rotated Sorted Array" 1 and 2 are expected to be solved with time complexity O(log(n)). Yet, since this solution involves more complex array index computation, linear solution might be faster for smaller n's
51. Palindrome Number
52. Populating Next Right Pointers in Each Node II
53. Minimum Depth of Binary Tree
54. Sum Root to Leaf Numbers
55. Trapping Rain Water
56. N Queens II
57. Valid Parentheses
58. Path Sum II
59. Length Of Last Word
60. Three Sum Closest
61. Unique Paths II
62. Valid Sudoku
63. Subsets
64. Jump Game
65. Longest Common Prefix
66. Convert Sorted List to BST
67. Longest Consecutive Sequence
68. Subsets II
69. Count and Say
70. Flatten Binary Tree to Linked List
    - Preorder BST traversal
71. Search for a Range
72. Binary Tree Zigzag Level Order Traversal

###<a name="6"></a>GENERAL ISSUE
1. Thread/Lock
2. Inheritance/Super
3. Testing With JUnit
4. Maximum Subarray Problem
5. Rod Cutting Problem
6. Longest Common Substring/Sunsequence
7. Breadth First Traversal
