#ProgrammingExercises

*This project is consist of my programming exercises, including Data Structure, Operator, Sorting, Exercises from "Cracking Coding Interview" and other General Issues*

======
###CONTENT
1. [Data Structure](#1)
2. [Operators and Java Concepts] (#2)
3. [Sorting] (#3)
4. [Exercises from "Cracking Coding Interview"] (#4)
5. [Exercises from LeetCode] (#5)
6. [Programming Questions] (#6)
 
======
###<a name="1"></a>Data Structure
1. Trie
2. Binary Search Tree
3. AVL Tree
4. LinkedList

###<a name="2"></a>Operators and Java Concepts
1. Exclusive Or
2. Ternary Operators
3. Bitwise Operation
4. Thread
5. Synchronization
6. Deadlock
7. Extend and Super
8. Enumeration

###<a name="3"></a>Sorting
1. Insertion Sort
2. Merge Sort
3. Heap Sort
4. Quick Sort
5. Counting Sort
6. Selection Sort

###<a name="4"></a>Exercises from "Cracking Coding Interview"
1. EXERCISE 19-10
    - Use a function that generate Integer in range (1, 5) to generate Interger in range (1, 7) randomly
    - There are various implementations for this exercise. **An interesting question is how to control the distribution if needed.** If there is any restriction on the output, can the new integer generator remain the same distribution? For uniform distribution, it is possible. However, if the origin generator outputs in normal distribution, some integral transform is required
2. EXERCISE 19-08
    - Need more clarification: how many searches will I need to perform? If more than once, I need to build a table for the frequency of each word. Besides, is the search case-sensitive? Should singular/plural, possessive forms of nouns to be considered?
3. EXERCISE 19-05
4. EXERCISE 19-03
5. EXERCISE 19-01
6. EXERCISE 19-05
    - Reflection and Annotation in Java
7. EXERCISE 14-04
8. EXERCISE 14-03
9. EXERCISE 14-02
10. EXERCISE 14-01
11. EXERCISE 11-01
12. EXERCISE 10-07
    - Solved with brute force ):
13. EXERCISE 10-03
14. EXERCISE 9-06
15. EXERCISE 9-05
16. EXERCISE 9-02
17. EXERCISE 9-01
18. EXERCISE 8-08
19. EXERCISE 8-07
20. EXERCISE 8-06
21. EXERCISE 8-05
22. EXERCISE 8-04
23. EXERCISE 8-03
24. EXERCISE 8-02
25. EXERCISE 8-01
26. EXERCISE 7-05
27. EXERCISE 7-02
28. EXERCISE 6-06
29. EXERCISE 6-03
    - A.K.A. [Water Pouring Problem] (http://demonstrations.wolfram.com/WaterPouringProblem/)
30. EXERCISE 5-06
31. EXERCISE 5-05
32. EXERCISE 5-01
33. EXERCISE 4-08
34. EXERCISE 4-07
35. EXERCISE 4-06
36. EXERCISE 4-05
37. EXERCISE 4-03
38. EXERCISE 3-06
39. EXERCISE 3-05
40. EXERCISE 3-04
41. EXERCISE 3-03
42. EXERCISE 3-02
43. EXERCISE 3-01
44. EXERCISE 2-05
45. EXERCISE 2-04
46. EXERCISE 2-03
47. EXERCISE 2-02
48. EXERCISE 2-01
49. EXERCISE 1-08
50. EXERCISE 1-07
51. EXERCISE 1-06
52. EXERCISE 1-05
53. EXERCISE 1-04
54. EXERCISE 1-03
55. EXERCISE 1-02
56. EXERCISE 1-01

###<a name="5"></a>Exercises from LeetCode
1. Same Tree
2. Reverse Integer
3. Best Time to Buy Stock
4. Linked List Cycle
5. Unique Binary Search Trees
6. Populating Next Right Pointers in Each Node
7. Remove Duplicates from Sorted List
8. Search Insert Position
9. Maximum Depth of Tree
10. Single Number Problem
11. Binary Tree Inorder Traversal
12. Binary Tree Preorder Traversal
    - It is within BinaryTreeInorderTraversal.java
13. Remove Element
14. Remove Duplicates From Sorted Array
15. Maximum Subarray
16. Climbing Stairs
17. Roman to Integer
18. Merge Two Sorted Lists
19. Merge Sorted Array
20. Symmetric Tree
21. Balanced Binary Tree
22. Best Time to Buy and Sell Stock IIi
    - Refer with "Best Time to Buy and Sell Stock"
    - When only one sell is allowed, it is in fact a Maximum Subarray Problem of the array contains profit of each day
23. Convert Sorted Array to Binary Search Tree
24. Integer to Roman
25. Pascal's Triangle
26. Single Number II
    - Refer with "Single Number Problem". Instead of twice, the noises are repeated three times this time
27. Swap Nodes in Pairs
28. Gray Code
29. Permutations
    - Recursion
30. Binary Tree Level Order Traversal II
    - Breadth first traversal
31. Generate Parentheses
32. Minimum Path Sum
    - Recursion works just fine, but solving with for-loop and some extra memory will improve the speed
33. Sort Colors
34. Linked List Cycle II
35. Rotate Image
36. Unique Paths
37. Binary Tree Level Order Traversal
38. Binary Tree Postorder Traversal
39. Set Matrix Zeroes
40. Container With Most Water
41. Plus One
42. Remove Nth Node from End of List
43. Search A 2D Matrix
44. Spiral Matrix II
45. Combinations
46. Pascals Triangle II
47. Path Sum
48. Remove Duplicates From Sorted Array II
49. Search in Rotated Sorted Array
50. Search in Rotated Sorted Array II
    - Note that "Search in Rotated Sorted Array" 1 and 2 are expected to be solved with time complexity O(log(n)). Yet, since this solution involves more complex array index computation, linear solution might be faster for smaller n's
51. Palindrome Number
52. Populating Next Right Pointers in Each Node II
53. Minimum Depth of Binary Tree
54. Sum Root to Leaf Numbers
55. Trapping Rain Water
56. N Queens II
57. Valid Parentheses
58. Path Sum II
59. Length Of Last Word
60. Three Sum Closest
61. Unique Paths II
62. Valid Sudoku
63. Subsets
64. Jump Game
65. Longest Common Prefix
66. Convert Sorted List to BST
67. Longest Consecutive Sequence
68. Subsets II
69. Count and Say
70. Flatten Binary Tree to Linked List
    - Preorder BST traversal
71. Search for a Range
72. Binary Tree Zigzag Level Order Traversal
73. Power
74. Partition List
75. Combination Sum
76. Triangle
77. Unique BST II
78. Letter Combinations of a Phone Number
79. Insertion Sort List
80. N Queens
81. Valid BST
82. Reverse Linked List II
83. Construct Binary Tree from Inorder and Postorder Traversal 
84. Construct Binary Tree from Inorder and Preorder Traversal
85. Add Binary
86. Next Permutation
87. Remove Duplicates from Sorted List II
88. Palindrome Partitioning
89. Edit Distance
90. Gas Station
91. Permutions II
92. Reverse Nodes in K Group
93. Distinct Sunsequences
94. Combination Sum II
95. Jump Game II
96. Longest Substring Without Repeating Characters
97. Merge K Sorted Lists
98. Anagrams
99. Add Two Numbers
100. Zig Zag Conversion
101. Recover Binary Search Tree
102. First Missing Positive
103. 4 Sum
104. Best Time to Buy and Sell Stock III
105. Rotate List
106. SqrtX
107. Copy List With Random Pointer
108. Valid Palindrome
109. Scramble String
110. Permutation Sequence
111. Clone Graph
112. Maximal Rectangle
113. Implement StrStr
114. Longest Palindromic Substring
115. Sudoku Solver
116. Largest Rectangle in Histogram
117. Insert Interval
118. Merge Intervals
119. Restore IP addresses
120. Sprial Matrix
121. Multiply Strings
122. Word Break
123. Sort List
124. Binary Tree Maximum Path Sum
125. Regular Expression Matching
126. Two Sum
127. Evaluate Reverse Polish Notation
128. Reorder List
129. Simplify Path
130. Word Search
131. Longest Valid Parenthese
132. Interleaving String
133. Palindrome Partitioning II
134. Substring With Concatenation of All Words 
135. Candy
136. Minimum Window Substring
137. Word Ladder
138. Median of Two Sorted Arrays
139. Decode Ways
140. Divide Two Integers
141. Reverse Words in a String
142. Three Sum
143. Word Break II
144. String to Integer
145. Surrounded Regions
146. Text Justification
147. LRU Cache
148. Wildcard Matching
149. Valid Number
150. Max Points on a Line
151. Word Ladder II

###<a name="6"></a>Programming Questions
1. Breadth First Traversal
2. K Palindrome
3. Rod Cutting
4. Longest Common Subsequence
5. Maximum Subarray
6. Bounded Slices
7. Anagram Substring
8. Majority Counting
9. Subarray Sum
10. Rearrange Array
11. Repeated Pattern
12. String Transformation
13. Kth of UnsortedArray
14. Serialize Binary Tree
15. Edit String
